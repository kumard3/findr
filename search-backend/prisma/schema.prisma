// schema.prisma

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

generator client {
    provider = "prisma-client-js"
}

model User {
    id        String   @id @default(cuid())
    email     String   @unique
    name      String?
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Authentication
    password   String? // Hashed password for email/password auth
    provider   String? // "google", "github", etc.
    providerId String? // External provider ID

    // Subscription and Usage
    tier    String @default("free") // free, pro, enterprise
    limit   Int    @default(1000) // Documents limit based on tier
    used    Int    @default(0) // Current usage count
    storage Int    @default(0) // Storage used in bytes

    // Billing
    customerId         String? // Payment provider customer ID
    subscriptionId     String? // Active subscription ID
    subscriptionStatus String? // active, canceled, past_due
    trialEndsAt        DateTime?

    // Relations
    apiKeys     ApiKey[]
    collections Collection[]
    usageLogs   UsageLog[]
    Account     Account[]
    Session     Session[]

    @@index([email])
    @@index([tier])
}

model ApiKey {
    id        String    @id @default(cuid())
    value     String    @unique
    name      String? // Optional key name/description
    userId    String
    user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    status    String    @default("active") // active, revoked, expired
    type      String    @default("search") // search, admin, write
    createdAt DateTime  @default(now())
    expiresAt DateTime?
    lastUsed  DateTime?

    // Rate Limiting
    rateLimit         Int      @default(100) // Requests per minute
    requestCount      Int      @default(0) // Current request count
    allowedOperations String[]
    // Permissions
    permissions       String[] // search, write, delete
    ipRestrictions    String[] // Allowed IP addresses

    @@index([value])
    @@index([userId])
    @@index([status])
}

model Collection {
    id        String   @id @default(cuid())
    name      String
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Collection Settings
    typesenseId   String // ID in Typesense
    documentCount Int    @default(0)
    storageSize   Int    @default(0) // in bytes

    // Schema Configuration
    schema   Json? // Stored schema configuration
    settings Json? // Collection settings

    // Relations
    usageLogs UsageLog[]

    @@unique([userId, name])
    @@index([userId])
}

model UsageLog {
    id           String      @id @default(cuid())
    userId       String
    user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
    collectionId String?
    collection   Collection? @relation(fields: [collectionId], references: [id])

    // Operation Details
    operation    String // search, index, delete
    timestamp    DateTime @default(now())
    status       String // success, failed
    errorMessage String?

    // Usage Metrics
    documentsProcessed Int?
    processingTime     Int? // in milliseconds
    dataSize           Int? // in bytes

    // Request Details
    apiKeyId  String?
    ipAddress String?
    userAgent String?
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([userId])
    @@index([collectionId])
    @@index([timestamp])
    @@index([operation])
}

model Tier {
    id       String @id @default(cuid())
    name     String @unique // free, pro, enterprise
    price    Float
    currency String @default("USD")
    interval String @default("month") // month, year

    // Limits
    documentLimit  Int
    storageLimit   Int // in bytes
    searchesPerDay Int
    apiKeys        Int
    collections    Int

    // Features
    features  String[]
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([name])
}

model BillingHistory {
    id        String    @id @default(cuid())
    userId    String
    amount    Float
    currency  String
    status    String // paid, pending, failed
    provider  String // stripe, paypal
    invoiceId String?
    createdAt DateTime  @default(now())
    paidAt    DateTime?

    @@index([userId])
    @@index([status])
}

// Necessary for Next auth
model Account {
    id                       String  @id @default(cuid())
    userId                   String
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? // @db.Text
    access_token             String? // @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? // @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}
